<!DOCTYPE html>
<html lang="en">
	<head>
        <title>deviceorientation</title>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no, initial-scale=1">
	<script src = "https://code.jquery.com/jquery-3.3.1.js"></script>
	<script src="build/three.js"></script>
	<link href ="https://font.googleleapix.com/css?family=Poppins:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i " rel="stylesheet">
    </head>
    <style>
	body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
            #header {
                position: absolute;
                top: 0px; width: 100%;
                color: #ffffff;
                padding: 5px;
                font-family:Poppins;
                font-size:13px;
                font-weight: bold;
                text-align:center;
                box-sizing: border-box;
            }
            
            #Main {
                position: absolute;
                top: 100px; width: 100%;
                color: #ffffff;
                padding: 5px;
                font-family:Poppins;
                font-size:13px;
                font-weight: bold;
                text-align:center;
                box-sizing: border-box;
            }
            a {
                color: #ff8800;
            }

.mybtn{
  margin-top:40px;
  width:60px;
  flex: 1 1 auto;
  padding:17px;
  border:2px solid #f7F7F7;
  text-align:center;
  text-transform:uppercase;
  position:relative;
  letter-spacing:2px;
  color:white;
}
    </style>
    <body>
	    <div id = "container">
            	<div id="header">
			<h1>台 灣 萊 雅</h1>
           	</div>
            	<div id="Main">
			<h1>Find your power stone</h1>
                	<h2>尋找你的能力寶石</h2>
			<button class ="mybtn" onclick="StartGamefunction()"> Clicknybtn </button>
            		<p id="demo"></p>
            	</div>
		<div id="Main2">
			<button class ="mybtn" onclick="StartGamefunction()"> Clicknybtn </button>
            	</div>
            
        </div>
	    
        <script src="build/three.js"></script>
	<script src="js/ar.js"></script>
        <script src="js/controls/DeviceOrientationControls.js"></script>
        <script src="js/WebGL.js"></script>
    	<script src="js/threex.domevents.js"></script>
   	<script src="js/TweenMax.min.js"></script>

        <script>
	var StartGame = false;
	function StartGamefunction(){
        	StartGame = true;
        	var x = document.getElementById("container");
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
  		}
	}
		
		
		init();
		animate();
		
		var domEvents = new THREEx.DomEvents(camera, renderer.domElement);
            	domEvents.addEventListener(planemesh , 'touchstart' , event =>{
                    this.t1 = new TimelineMax();
                    this.t1.to(planemesh.scale, 0.5 , { x:0 , y:0 , z:0 , ease:Expo.easeOut});
                })
           	domEvents.addEventListener(planemesh2 , 'touchstart' , event =>{
                   this.t2 = new TimelineMax();
                   this.t2.to(planemesh2.scale, 0.5 , { x:0 , y:0 , z:0 , ease:Expo.easeOut});
            	})
		
	}
		
	var camera, scene, renderer, controls;
	function init(){	
	renderer = new THREE.WebGLRenderer({
		antialias: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );
	// array of functions for the rendering loop
	var onRenderFcts= [];
	// init scene and camera
		
	scene	= new THREE.Scene();
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Initialize a basic camera
	//////////////////////////////////////////////////////////////////////////////////
	// Create a camera
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
	controls = new THREE.DeviceOrientationControls( camera );
	scene.add(camera);
		// init renderer
	
	
	////////////////////////////////////////////////////////////////////////////////
	//          handle arToolkitSource
	////////////////////////////////////////////////////////////////////////////////
	var arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
		sourceType : 'webcam',		
	})
	arToolkitSource.init(function onReady(){
		onResize()
	})
	
	// handle resize
	window.addEventListener('resize', function(){
		onResize()
	})
		
	function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}
	////////////////////////////////////////////////////////////////////////////////
	//          initialize arToolkitContext
	////////////////////////////////////////////////////////////////////////////////
	
	// create atToolkitContext
	var arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
		detectionMode: 'mono',
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})
	// update artoolkit on every frame
	onRenderFcts.push(function(){
		if( arToolkitSource.ready === false )	return
		arToolkitContext.update( arToolkitSource.domElement )
		
		// update scene.visible if the marker is seen
		scene.visible = camera.visible
	})
		
	////////////////////////////////////////////////////////////////////////////////
	//          Create a ArMarkerControls
	////////////////////////////////////////////////////////////////////////////////
	
	// init controls for camera
	//var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
	//	type : 'pattern',
	//	patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
		// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
		// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
	//	changeMatrixMode: 'cameraTransformMatrix'
	//})
	// as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
	
	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
		
	
	var helperGeometry = new THREE.BoxBufferGeometry( 100, 100, 100, 4, 4, 4 );
                var helperMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
                var helper = new THREE.Mesh( helperGeometry, helperMaterial );
                scene.add( helper );	
	
	var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
        var geometry = new THREE.PlaneGeometry( 50,50);
        var material = new THREE.MeshBasicMaterial( { map: texture } );
        planemesh = new THREE.Mesh( geometry, material );
        planemesh.rotation.y = 90 ;
        planemesh.position.set( -100, 0, 0 );
        scene.add( planemesh );
                
        var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
        var geometry = new THREE.PlaneGeometry( 50,50);
        var material = new THREE.MeshBasicMaterial( { map: texture } );
        planemesh2 = new THREE.Mesh( geometry, material );
        planemesh2.rotation.y = 90 ;
        planemesh2.position.set( -100, 50, 0 );
        scene.add( planemesh2 );
	window.addEventListener( 'resize', onWindowResize, false );
	}
	
            
	//////////////////////////////////////////////////////////////////////////////////
	
	
//	onRenderFcts.push(function(delta){
//		mesh.rotation.x += Math.PI*delta
//	})
	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////
	// render the scene
//	onRenderFcts.push(function(){
//		renderer.render( scene, camera );
//	})
	// run the rendering loop
/*	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
	*/
	
	
	
		

		
		
	function animate() {
                window.requestAnimationFrame( animate );
                controls.update();
                renderer.render( scene, camera );
            }
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
        </script>
    </body>
</html>
