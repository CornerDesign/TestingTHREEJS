
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>deviceorientation</title>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no, initial-scale=1">
	<script src = "http://code.jquery.com/jquery-3.3.1.js"></script>
	<link rel = "stylesheet" herf="index.css">
    </head>
    <body>
	    <div id = "container">
            <div id="header">

            </div>
            
            <div id="Main">
                <h3>main message </h2>
                <h2>Submit Button</h2>
                <p>The <strong>input type="submit"</strong> defines a button for submitting form data to a form-handler:</p>
		<button id ="mybtn" onclick="StartGamefunction()"> Clicknybtn </button>
           <button onclick="StartGamefunction()">Click me</button>
            <p id="demo"></p>
            </div>
            
        </div>
	    
        <script src="build/three.js"></script>
	<script src="js/ar.js"></script>
        <script src="js/controls/DeviceOrientationControls.js"></script>
        <script src="js/WebGL.js"></script>
    	<script src="js/threex.domevents.js"></script>
   	<script src="js/TweenMax.min.js"></script>

        <script>
	var StartGame = false;
	function StartGamefunction(){
        	StartGame = true;
        	document.getElementById("demo").innerHTML = "Hello World";
		init();
		animate();
		
		var domEvents = new THREEx.DomEvents(camera, renderer.domElement);
            	domEvents.addEventListener(planemesh , 'touchstart' , event =>{
                    this.t1 = new TimelineMax();
                    this.t1.to(planemesh.scale, 0.5 , { x:0 , y:0 , z:0 , ease:Expo.easeOut});
                })
           	domEvents.addEventListener(planemesh2 , 'touchstart' , event =>{
                   this.t2 = new TimelineMax();
                   this.t2.to(planemesh2.scale, 0.5 , { x:0 , y:0 , z:0 , ease:Expo.easeOut});
            	})
		
	}
		
	var camera, scene, renderer, controls;
	function init(){	
	renderer = new THREE.WebGLRenderer({
		antialias: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );
	// array of functions for the rendering loop
	var onRenderFcts= [];
	// init scene and camera
		
	scene	= new THREE.Scene();
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Initialize a basic camera
	//////////////////////////////////////////////////////////////////////////////////
	// Create a camera
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
	controls = new THREE.DeviceOrientationControls( camera );
	scene.add(camera);
		// init renderer
	
	
	////////////////////////////////////////////////////////////////////////////////
	//          handle arToolkitSource
	////////////////////////////////////////////////////////////////////////////////
	var arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
		sourceType : 'webcam',		
	})
	arToolkitSource.init(function onReady(){
		onResize()
	})
	
	// handle resize
	window.addEventListener('resize', function(){
		onResize()
	})
		
	function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
	}
	////////////////////////////////////////////////////////////////////////////////
	//          initialize arToolkitContext
	////////////////////////////////////////////////////////////////////////////////
	
	// create atToolkitContext
	var arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
		detectionMode: 'mono',
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})
	// update artoolkit on every frame
	onRenderFcts.push(function(){
		if( arToolkitSource.ready === false )	return
		arToolkitContext.update( arToolkitSource.domElement )
		
		// update scene.visible if the marker is seen
		scene.visible = camera.visible
	})
		
	////////////////////////////////////////////////////////////////////////////////
	//          Create a ArMarkerControls
	////////////////////////////////////////////////////////////////////////////////
	
	// init controls for camera
	//var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
	//	type : 'pattern',
	//	patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
		// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
		// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
	//	changeMatrixMode: 'cameraTransformMatrix'
	//})
	// as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
	
	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
		
	
	var helperGeometry = new THREE.BoxBufferGeometry( 100, 100, 100, 4, 4, 4 );
                var helperMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
                var helper = new THREE.Mesh( helperGeometry, helperMaterial );
                scene.add( helper );	
	
	var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
        var geometry = new THREE.PlaneGeometry( 50,50);
        var material = new THREE.MeshBasicMaterial( { map: texture } );
        planemesh = new THREE.Mesh( geometry, material );
        planemesh.rotation.y = 90 ;
        planemesh.position.set( -100, 0, 0 );
        scene.add( planemesh );
                
        var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
        var geometry = new THREE.PlaneGeometry( 50,50);
        var material = new THREE.MeshBasicMaterial( { map: texture } );
        planemesh2 = new THREE.Mesh( geometry, material );
        planemesh2.rotation.y = 90 ;
        planemesh2.position.set( -100, 50, 0 );
        scene.add( planemesh2 );
	window.addEventListener( 'resize', onWindowResize, false );
	}
	
            
	//////////////////////////////////////////////////////////////////////////////////
	
	
//	onRenderFcts.push(function(delta){
//		mesh.rotation.x += Math.PI*delta
//	})
	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////
	// render the scene
//	onRenderFcts.push(function(){
//		renderer.render( scene, camera );
//	})
	// run the rendering loop
/*	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
	*/
	
	
	
		

		
		
	function animate() {
                window.requestAnimationFrame( animate );
                controls.update();
                renderer.render( scene, camera );
            }
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
        </script>
    </body>
</html>
