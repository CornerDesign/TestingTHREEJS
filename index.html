
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>deviceorientation</title>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no, initial-scale=1">
        <style>
            body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script src="build/three.js"></script>
	<script src="js/ar.js"></script>
        <script src="js/controls/DeviceOrientationControls.js"></script>
        <script src="js/WebGL.js"></script>
    	<script src="js/threex.domevents.js"></script>
   	<script src="js/TweenMax.min.js"></script>
	
        <video id="video" autoplay style="display:none"></video>
        
        <script>
		var camera, scene, controls,video;
		
		var renderer	= new THREE.WebGLRenderer({
			antialias: true,
			alpha: true
		});
		
            //
   		renderer = new THREE.WebGLRenderer( { antialias: true } );
           	renderer.setPixelRatio( window.devicePixelRatio );
            	renderer.setSize( 640, 480 );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.body.appendChild( renderer.domElement );
		
		// array of functions for the rendering loop
		var onRenderFcts= [];
		
		function init() {
			scene = new THREE.Scene();
                	camera = new THREE.Camera();
			scene.add(camera);
                	controls = new THREE.DeviceOrientationControls( camera );
		   
		var arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
			sourceType : 'webcam',
		})
		arToolkitSource.init(function onReady(){
			onResize()
		})
	
		// handle resize
		window.addEventListener('resize', function(){
			onResize()
		})
		function onResize(){
			arToolkitSource.onResize()	
			arToolkitSource.copySizeTo(renderer.domElement)	
			if( arToolkitContext.arController !== null ){
				arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
			}	
		}
		// create atToolkitContext
		var arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
			detectionMode: 'mono',
		})
		// initialize it
		arToolkitContext.init(function onCompleted(){
			// copy projection matrix to camera
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		})
			/*
		// update artoolkit on every frame
		onRenderFcts.push(function(){
			if( arToolkitSource.ready === false )	return
				arToolkitContext.update( arToolkitSource.domElement )
		
			// update scene.visible if the marker is seen
			scene.visible = camera.visible
		})
        */
        	var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
		var geometry = new THREE.PlaneGeometry( 50,50);
      	 	var material = new THREE.MeshBasicMaterial( { map: texture } );
     	   	planemesh = new THREE.Mesh( geometry, material );
        	planemesh.rotation.y = 90 ;
        	planemesh.position.set( -100, 0, 0 );
        	scene.add( planemesh );
                
       	 	var texture = new THREE.TextureLoader().load( 'textures/fish.png' );
        	var geometry = new THREE.PlaneGeometry( 50,50);
        	var material = new THREE.MeshBasicMaterial( { map: texture } );
        	planemesh2 = new THREE.Mesh( geometry, material );
        	planemesh2.rotation.y = 90 ;
        	planemesh2.position.set( -100, 50, 0 );
        	scene.add( planemesh2 );
            
                            
                if ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {
                    var constraints = {
                        video: {
                            //width: 1280, height: 720, facingMode: "user" //使用前鏡頭
                            width: 1280, height: 720, facingMode: { exact: "environment" }//使用後鏡頭
                        }
                    };
                    navigator.mediaDevices.getUserMedia( constraints ).then(
                        function ( stream ) {    
                        // apply the stream to the video element used in the texture
                        video.srcObject = stream;
                        video.play();
                        } ).catch( function ( error ) {
                            console.error( 'Unable to access the camera/webcam.', error );
                    } );
                } else {
                    console.error( 'MediaDevices interface not available.' );
                }
            }
		

        
        
       
        
        
            function animate() {
                window.requestAnimationFrame( animate );
                controls.update();
                renderer.render( scene, camera );
            }
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
        </script>
    </body>
</html>
